from itertools import product, chain
import signal as signal

from .typing import *
from .tau import *
from .inequality import *
from .utils import filter_dict_by_key
from .rings import *
from .rings import variable
from .vector_chooser import *
from .root import *
from .weight import *
from .permutation import *
from .representation import *

#from .utils import dictionary_list_lengths

#dict_Vtau_neg_ou_nul(tau0)=filter_dict_by_key(tau.grading_weights, lambda x: x <= 0)

#Dict_wUw(ineq)=ineq.tau.grading_roots_in(ineq.inversions) (flattened)


    
    

 
def classif_roots(V: Representation, roots: Iterable[Root]) -> list[list[list[Root]]]:
    """
    Sorts the roots of list_roots in a list of list of roots. First coordinate corresponding to root.k (useful only for kron type) and second coordinate corresponding to root.j (the roots with non-trival action on a weight involving epsilon_j)
    >>> G = LinearGroup([4,4,4,1])
    >>> V = KroneckerRepresentation(G)
    >>> classif_roots(V,Root.all_of_U(G))
    [[[],
      [Root(k=0, i=0, j=1)],
      [Root(k=0, i=0, j=2), Root(k=0, i=1, j=2)],
      [Root(k=0, i=0, j=3), Root(k=0, i=1, j=3), Root(k=0, i=2, j=3)]],
     [[],
      [Root(k=1, i=0, j=1)],
      [Root(k=1, i=0, j=2), Root(k=1, i=1, j=2)],
      [Root(k=1, i=0, j=3), Root(k=1, i=1, j=3), Root(k=1, i=2, j=3)]],
     [[],
      [Root(k=2, i=0, j=1)],
      [Root(k=2, i=0, j=2), Root(k=2, i=1, j=2)],
      [Root(k=2, i=0, j=3), Root(k=2, i=1, j=3), Root(k=2, i=2, j=3)]]]
    """
    Res: list[list[list[Root]]] = [[[] for j in range(V.G[k])] for k in range(len(V.G))]
    if isinstance(V, KroneckerRepresentation):
        Res=Res[:-1]
    for root in roots:
        Res[root.k][root.j].append(root)
    return Res

def weight_as_list(weight: Weight) -> list[int]:
    if isinstance(weight, WeightAsList):
        return list(weight.as_list)
    elif isinstance(weight, WeightAsListOfList):
        return list(weight.as_list_of_list[0])
    else:
        raise NotImplementedError("Only for WeightAsList and WeightAsListOfList")
        
#TODO: define smaller polynomial rings?

def map_pi(V: Representation, weights_domain: Sequence[Weight], roots_domain: Sequence[Root], method: Method) -> list[Vector]:
    """ Compute the map pi (i.e. the orbit map V times U-> V restricted to V_restr times U_restr where V_restr is the subspace generated by weight spaces of the weights in "weights_domains" while U_restr is the subgroup generated by root subgroups associated to roots in "roots_domain".)
    if method is "symbolic", result is given in terms of formal variables of V_restr and formal variables of U_restr
    if method is "probabilistic", result is given as the image of a random point in V restricted (and formal variables of U_rest
    """
    if method == "probabilistic":
        ring = V.QI
        bigring=V.G.QU_Q
    elif method == "symbolic":
        ring = V.QV
        bigring = V.QU_QV
    else:
        raise ValueError(f"Invalid value {method} of the computation method")
    
    if isinstance(V, KroneckerRepresentation):
        degree = len(V.G)-1
    else:
        assert(isinstance(V, ParticleRepresentation))
        degree = V.particle_cnt

    v: Vector = point_vect(weights_domain, V, ring, bounds=(-1000, 1000))
    classified_roots=classif_roots(V,roots_domain)  
    for k in range(len(classified_roots)):
        for j in range(V.G[k]):
            classified_roots[k][j].append(Root(k,j,j)) #include roots i=j.
    if isinstance(V, ParticleRepresentation):
        classified_roots *= V.particle_cnt #

    Res: list[Vector] = [0 for i in range(len(v))] #null vector
    for i, weight in enumerate(weights_domain):
        selected_roots=[] #for each v_k in a (tensor, wedge, symmetric) product prod(v_k), we select the roots with non-zero action of the considered v_k.
        for k in range(degree):
            selected_roots.append(classified_roots[k][weight_as_list(weight)[k]])
        compatible_tuples_of_roots=product(*selected_roots) #tuples of roots with non-zero action on the weight space

        for tuple_roots in compatible_tuples_of_roots:
            target_weight_coeffs: list[int] = [tuple_roots[k].i for k in range(degree)]
            #print(weight,target_weight)
            coef=1 #coefficient for the considered monomial
            compute=True #in fermionic cases, some target weights are non-eligible (those with repetition)

            target_weight: Weight
            if isinstance(V, ParticleRepresentation):
                if isinstance(V, FermionRepresentation):
                    coef=(-1)**(Permutation(target_weight_coeffs).length)#taking into account -1 sign in reordering wedge product
                target_weight_coeffs.sort()

                if isinstance(V, FermionRepresentation):
                    compute=sum([target_weight_coeffs[i]==target_weight_coeffs[i+1] for i in range(degree-1)])==0

                target_weight = WeightAsListOfList(V.G, as_list_of_list=[target_weight_coeffs])

            else:
                assert(isinstance(V, KroneckerRepresentation))
                target_weight = WeightAsList(V.G, as_list=target_weight_coeffs+[0])

            for root in tuple_roots:
                if root.i!=root.j:
                    coef*=variable(ring_or_gens= bigring, id=root,seed="u")
            if compute: #in fermionic cases v\wedge v=0:
                Res[V.index_of_weight(target_weight)]+=v[V.index_of_weight(weight)]*coef
    return Res
    

def eq_fibre_pi(V: Representation, ineq: Inequality, method: Method) -> list[Vector]:
    """ returns equation for a fibre of the map pi.
    if method is "symbolic", the result is given for a generic fiber 
    if method is "probabilistic", the fiber is a that of the image of (e,v) for v a random vector in V_restr
    """
    non_positive_weights = list(chain.from_iterable(ineq.tau.non_positive_weights(V).values())) #weights which are non-positive with respect to tau
    positive_weights = list(chain.from_iterable(ineq.tau.positive_weights(V).values()))
    roots_U=list(ineq.inversions) #roots in U cap w^{-1}Uw.
    map_formula=map_pi(V,non_positive_weights,roots_U,method)
    Res: list[Vector] = []
    for weight in positive_weights:
        Res.append(map_formula[V.index_of_weight(weight)])
    return Res
    
def Groebner_basis_brut(V: Representation, ineq: Inequality, method: Method) -> Any:
    """
    Computes a Gröbner basis for the equations of a fiber of the map pi
    """
    eq=eq_fibre_pi(V,ineq,method)
    if len(eq)>0:
        R=eq[0].parent()
        II=R.ideal(eq) 
        #print(R,II,eq)
        return II.groebner_basis()
    elif len(list(ineq.inversions))==0:
        return "special case: trivial map"
    else:
        raise ValueError(f"no equations for the fiber; ineq {ineq}, dimV_retr={len(list(chain.from_iterable(ineq.tau.non_positive_weights(V).values())))}, codimV_restr={list(chain.from_iterable(ineq.tau.positive_weights(V).values()))}, dimU={list(ineq.inversions)}")
      

def is_fiber_singleton(V: Representation, ineq: Inequality, method: Method) -> bool:
   """
   returns True if the fiber (either formal or random, depending on the method) is a single point or not.
   """
   GB=Groebner_basis_brut(V,ineq,method)
   if GB=="special case: trivial map":
       return True
   dic={-1:len(list(ineq.inversions))}
   for eq in GB:
      dg=eq.degree()
      if dg in dic.keys():
         dic[dg]+=1
      else:
         dic[dg]=1
   dgs=dic.keys()
   t=(len(dgs)==2) and (1 in dgs) and (dic[1]==dic[-1])
   if not(t):
      print(dic)
   return t

def is_fiber_singleton_reorder(ineq: Inequality, V: Representation, method: Method) -> bool:
    """
    for developpment purposes
    """
    return is_fiber_singleton(V,ineq,method)
    

def long_calculation(Liste: Sequence[T], function: Callable[..., U], lim: int, extra_arguments: Iterable[Any]) -> list[tuple[int, T, U]]:
    """
    For each element of Liste,
    computes function applied to each element, (and common list of extra_arguments for each call)
    if time of computation exceeds lim seconds, computation is stopped.
    """
    Res: list[tuple[int, T, U]] = []
    for i,l in enumerate(Liste):
       signal.alarm(lim)
       succ = True
       resl = None
       try:
           print('starting calculation ', i,' over',len(Liste)) 
           resl=function(l,*extra_arguments)
       except:
           print('did not complete! in ', lim, ' seconds')
           succ=False
       # if the computation finished early, though, the alarm is still ticking!
       # so let's turn it off..
       signal.alarm(0)
       #cancel_alarm()
       if succ:
          print(i, "success. Result is", resl)
          assert resl is not None
          Res.append((i, l, resl))
       else: 
          print(i, "fail")
    print(len(Res), " over ", len(Liste), " computations finished")
    if len(Res)>0 and type(Res[0][-1])==bool:
       print(len([m for m in Res if m[-1]]), "results with output True")
    return Res

def Grobner_List_Test(Liste: Sequence[Any], lim: int, V: Representation, method: Method):
    # FIXME: les éléments de Grobner_res sont de simples bool, et non des listes
    Grobner_Res=long_calculation(Liste,is_fiber_singleton_reorder,lim,[V,method])
    Grobner_True=[m[1] for m in Grobner_Res if m[2]]
    Grobner_False=[m[1] for m in Grobner_Res if not(m[2])]
    conclusive_indices=[m[0] for m in Grobner_Res]
    Grobner_Inconclusive=[Liste[i] for i in range(len(Liste)) if not(i in conclusive_indices)]
    print(len(Grobner_True),'true inequalities found by Grobner method, ', len(Grobner_Inconclusive), 'inconclusive inequalities')
    return Grobner_True, Grobner_Inconclusive


