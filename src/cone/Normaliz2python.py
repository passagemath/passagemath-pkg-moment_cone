from .typing import *
from re import split as re_split
from .tau import *
from .inequality import *
from .utils import dictionary_list_lengths

def convert_lines_Nout2pyth(lines:Sequence[str],d:"Dimension") -> Sequence[Tau]:
    """ lines is a list of lines read from a Normaliz output file, e.g. via
    fichier = open("/home/bm29130h/Documents/Recherche/Ressources_autres/GDT/Machine Learning/calculs Kron/2 oct/ineq_Normaliz"+st+".out","r")
    lines = fichier.readlines()
    fichier.close() 
    
    They are converted to 1 parameter compatible with our implementation. 
    """
    res=[]
    concerned_line=False
    for l in lines[16:]:
        if l=='\n':
            concerned_line=False
        if concerned_line:
            mp=[]
            m=re_split(r" ",l)
            m[-1]=m[-1][:-1]
            mp=[]
            for mm in m:
                if mm!='':
                   mp.append(int(mm))
            res.append(Tau.from_flatten(mp,d))
        if l[-21:]=="support hyperplanes:\n":
            concerned_line=True
    return(res)

def convert_file_Nout2pyth(rep_path:str, d:"Dimension") -> Sequence[Tau]:
    """rep_path is the path to the repository containing a Normaliz output, d is the dimension under concern (typically, a given repository can contain many Normaliz outputs for differents dimension d. e.g. path="/home/bm29130h/Documents/Recherche/Ressources_autres/GDT/Machine Learning/calculs Kron/2 oct/"
    
    the function then applies convert_lines_Nout2pyth
    """
    st=""
    for di in d:
       st+="-"+str(di)
    fichier = open(rep_path+"ineq_Normaliz"+st+".out","r")
    lines = fichier.readlines()
    fichier.close() 
    return(convert_lines_Nout2pyth(lines,d))

#path="/home/bm29130h/Documents/Recherche/Ressources_autres/GDT/Machine Learning/calculs Kron/2 oct/"
#reference=convert_file_Nout2pyth(path,d)

    
def compare_ineq_candidates_reference_mod_sym_dim(Candidates:Sequence[Inequality],Reference:Sequence[Inequality])->dict[str,Sequence[Inequality]]:
    """
    compares a list of inequalities generated by our program typically with former list of inequalities of earlier reference produced by Normaliz output. Example of call of such function in main_to_be_insterted.py
    
    the output is a dictionnary of lists of inequalities modulo symmetry which either belong only to Candidates, only to Reference or to both.
    """
    l1=list(unique_modulo_symmetry_list_of_tau([ineq.wtau.sl_representative.opposite for ineq in Candidates])) #in early stages we produce opposite of inequalities
    l1f=set(full_under_symmetry_list_of_tau(l1)) #we will need to compare elements of l2 to possibly permuted elements of l1
    l2=list(unique_modulo_symmetry_list_of_tau([ineq.wtau.sl_representative for ineq in unique_modulo_symmetry_list_of_ineq(Reference)]))
    l2f=set(full_under_symmetry_list_of_tau(l2))
    print(len(l1),len(l2),l1[55] in l1, l1[55] in l1f)
    res = {key: [] for key in ["candidates_only","reference_only","both"]}
    #print(len(list(l1)),len(list(l1f)),len(list(l2)),len(list(l2f)))
    for wtau in list(set(l1+l2)):
        wtau_opp=wtau.opposite
        ineq=Inequality.from_tau(wtau_opp) #we will store this orginal inequality in our results
        if wtau in l1f:
            if wtau in l2f: 
                res["both"].append(ineq)
            else:
                res["candidates_only"].append(ineq)
        elif wtau in l2f: 
            res["reference_only"].append(ineq)
    print(dictionary_list_lengths(res))
    #print(len(res["cand_only"]), "irredundant inequalities found in given list")
    #print(len(res["both"]), "redundant inequalities found in given list")
    return(res)

"""
#intermediate version. Not sure it is working

def compare_tau_candidates_reference_mod_sym_dim(Candidates:Sequence[Tau],Reference:Sequence[Tau])->dict[str,Sequence[Tau]]:
    l1=[tau.end0_representative for tau in unique_modulo_symmetry_list_of_tau(Candidates)]
    l2=[tau.end0_representative for tau in unique_modulo_symmetry_list_of_tau(Reference)]
    res = {key: [] for key in ["candidates_only","reference_only","both"]}
    for tau in list(set(l1+l2)):
        if tau in l1:
            if tau in l2: 
                res["both"].append(tau)
            else:
                res["candidates_only"].append(tau)
        else: 
            res["reference_only"].append(tau)
    print(dictionary_list_lengths(res))
    #print(len(res["cand_only"]), "irredundant inequalities found in given list")
    #print(len(res["both"]), "redundant inequalities found in given list")
    return(res)

"""

#ineq_normaliz=convertre(lines)

#ineq_normaliz_SL=[tau2SL(ineq,d0) for ineq in ineq_normaliz] 

#ineq







